Recursion 需要掌握的知识点：
    1) 表象上：function calls itself
    2) 实质上：Boil down a big problem to smaller ones (size n depends
              on size n-1, or n-2 or ...n/2)
    3) Implementation上：
        a) Base case: smallest problem to solve
        b) Recursive rule. how to make the problem smaller (if
           we can resolve the same problem but with a smaller size, then
           what is left to do for the current problem size n)

Call Stack: can be regarded as a global accessible information that tells
you what happened before each break point in each level.

Using Fibonacci example:
                F(4)                   O(1)
        F(3)            F(2)           O(2)
    F(2)    F(1)    F(1)    F(0)       O(4)
  F(1) F(0)

Base case is F(1) and F(0):
    F(0) --> 0
    F(1) --> 1

How to analyze time and space complexity of a recursive function?
● Time complexity: the sum of time complexity of all nodes in the recursion tree
● Space complexity: the sum of space complexity of all nodes on a path from top to bottom

中⽂翻译
● Recursion tree ⾥所有节点的时间复杂度之和
● Recursion tree ⾥⼀条直上直下的路径上所有节点的空间复杂度之和

常⻅错误(不要犯以下错误)
● Recursive function 的时间复杂度等于 recursion tree ⾥节点的总个数？
● Recursive function 的时间复杂度等于最后⼀层节点的个数？
● Recursive function 的时间复杂度等于最后⼀层节点的时间复杂度之和？
● Recursive function 的空间复杂度等于 recursion tree 的层数或者⾼度？
● Recursive function 的空间复杂度等于所有节点的空间复杂度之和？

Fibonacci
    Time Complexity: O(1 + 2 + 2^2 + 2^3 + 2^4 + ... + 2^(n-1)) = O(2^n)
    Space Complexity: O(n)

做题要求：
A complete answer will include the following:
    1. Document your assumptions
    2. Explain your approach and how you intend to solve the problem
    3. Provide code comments where applicable
    4. Explain the big-O run time complexity of your solution. Justify your answer.
    5. Identify any additional data structures you used and justify why you used them.
    6. Only provide your best answer to each part of the question.